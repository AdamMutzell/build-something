
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  labels:
    io.kompose.service: db-data
  name: db-data
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 100Mi
---
apiVersion: v1
data:
  db-password: S1VkQXJha3huR25mRUpNM0pBMlBnaQ==
kind: Secret
metadata:
  labels:
    io.kompose.service: db-password
  name: db-password
type: Opaque
---
apiVersion: v1
data:
  db-user: cm9vdAo=
kind: Secret
metadata:
  labels:
    io.kompose.service: db-user
  name: db-user
type: Opaque
---
apiVersion: v1
data:
  schema.sql: |
    -- schema.sql

    -- Make sure schema exists
    CREATE DATABASE IF NOT EXISTS event_store;

    -- Switch to schema
    USE event_store;

    -- Example table
    CREATE TABLE IF NOT EXISTS events (
        id INT AUTO_INCREMENT PRIMARY KEY,
        title VARCHAR(255) NOT NULL,
        start datetime DEFAULT CURRENT_TIMESTAMP,
        end datetime DEFAULT CURRENT_TIMESTAMP,
        creationId INT NOT NULL DEFAULT 0,
        created_at datetime DEFAULT CURRENT_TIMESTAMP,
        description TEXT,
        available BOOLEAN DEFAULT FALSE,
        payload JSON
    );

    -- Insert a sample event
    INSERT INTO events (title, start, end, created_at, description, available, payload)
    VALUES ('sample', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, 'test', TRUE, JSON_OBJECT('username', 'alice', 'email', 'alice@example.com'));
kind: ConfigMap
metadata:
  labels:
    io.kompose.service: event-store
  name: event-store-cm1
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: event-store
  labels:
    io.kompose.service: event-store
spec:
  serviceName: "event-store"
  replicas: 1
  selector:
    matchLabels:
      io.kompose.service: event-store
  template:
    metadata:
      labels:
        io.kompose.service: event-store
    spec:
      containers:
        - name: event-store
          image: mysql:8.0
          env:
            - name: MYSQL_DATABASE
              value: event_store
            - name: MYSQL_ROOT_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: db-password
                  key: db-password
          ports:
            - containerPort: 3306
              protocol: TCP
          volumeMounts:
            - name: db-data
              mountPath: /var/lib/mysql
            - name: event-store-cm1
              mountPath: /docker-entrypoint-initdb.d
            - name: db-password
              mountPath: /run/db-secrets/db-password
              subPath: db-password
      volumes:
        - name: db-password
          secret:
            items:
              - key: db-password
                path: db-password
            secretName: db-password
        - configMap:
            name: event-store-cm1
          name: event-store-cm1
  volumeClaimTemplates:
    - metadata:
        name: db-data
      spec:
        accessModes: [ "ReadWriteOnce" ]
        resources:
          requests:
            storage: 100Mi
---
apiVersion: v1
kind: Service
metadata:
  annotations:
    kompose.cmd: kompose convert
    kompose.version: 1.37.0 (HEAD)
  labels:
    io.kompose.service: event-store
  name: event-store
spec:
  type: ClusterIP
  ports:
    - name: "mysql"
      port: 3306
      targetPort: 3306
  selector:
    io.kompose.service: event-store
  
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: frontend-env
data:
  env.js: |
    window.API_BASE_URL = 'http://localhost:31567';
---

apiVersion: apps/v1
kind: Deployment
metadata:
  annotations:
    kompose.cmd: kompose convert
    kompose.version: 1.37.0 (HEAD)
  labels:
    io.kompose.service: frontend
  name: frontend
spec:
  replicas: 3
  selector:
    matchLabels:
      io.kompose.service: frontend
  strategy:
    type: Recreate
  template:
    metadata:
      annotations:
        kompose.cmd: kompose convert
        kompose.version: 1.37.0 (HEAD)
      labels:
        io.kompose.service: frontend
    spec:
      containers:
        - image: arrow02/angular-calendar:latest
          name: frontend
          ports:
            - containerPort: 4200
              protocol: TCP
          volumeMounts:
            - name: frontend-env
              mountPath: /usr/share/nginx/html/assets/env.js
              subPath: env.js
      volumes:
        - name: frontend-env
          configMap:
            name: frontend-env
      restartPolicy: Always
---
apiVersion: v1
kind: Service
metadata:
  annotations:
    kompose.cmd: kompose convert
    kompose.version: 1.37.0 (HEAD)
  labels:
    io.kompose.service: frontend
  name: frontend
spec:
  type: LoadBalancer
  ports:
    - name: "4200"
      port: 4200
      targetPort: 4200
  selector:
    io.kompose.service: frontend
---
apiVersion: v1
data:
  email_service.py: "# using flask_restful\nfrom flask import Flask, jsonify, request\nfrom flask_cors import CORS\n\nfrom flask_restful import Resource, Api\nimport smtplib\nfrom email.message import EmailMessage\nimport logging\n\n# ...existing imports...\nimport os\nimport mysql.connector\n\n# Helper to read Docker secrets\ndef get_secret(secret_path):\n    try:\n        with open(secret_path, 'r') as f:\n            return f.read().strip()\n    except Exception as e:\n        app.logger.error(f\"Failed to read secret {secret_path}: {e}\")\n        return None\n\n# Read secrets at startup\nDB_USER = get_secret('/run/secrets/db_user')\nDB_PASSWORD = get_secret('/run/secrets/db_password')\n# creating the flask app\napp = Flask(__name__)\nCORS(app)\n# Set up logging\nlogging.basicConfig(level=logging.INFO)\n# creating an API object\napi = Api(app)\n\nclass Hello(Resource):\n\n    def get(self):\n        app.logger.info(\"GET request received at Hello endpoint\")\n        return {'message': 'hello world'}\n\n    def post(self):\n        data = request.get_json()\n        app.logger.info(f\"POST request received at Hello endpoint with data: {data}\")\n        return {'data': data}, 201\n\nclass Square(Resource):\n    def post(self):\n        data = request.get_json()\n        num = data.get('num', 0)\n        app.logger.info(f\"POST request received at Square endpoint with num: {num}\")\n        return jsonify({'square': num**2})\n\nclass Link(Resource):\n    def get(self):\n        return {'message': 'This is the Link endpoint'}\n    \n    def post(self):\n        # Get a link to the page that displays the calendar events\n        data = request.get_json()\n        app.logger.info(f\"POST request received at Link endpoint with data: {data}\")\n        return {'data': data}, 201\n\n\nclass FetchEvents(Resource):\n    def __init__(self):\n        self.conn = create_database_connection()\n        self.cursor = self.conn.cursor()\n\n    def get(self):\n        return {'message': 'This is the FetchEvents endpoint'}\n    \n    def post(self):\n        data = request.get_json()\n        app.logger.info(f\"GET request received at Database endpoint with data: {data}\")\n        get_event_query = \"SELECT * FROM events WHERE creationId = %s\"\n        creation_id = data.get('creationId')\n        self.cursor.execute(get_event_query, (creation_id,))\n        events = self.cursor.fetchall()\n        app.logger.info(f\"Fetched events: {events}\")\n        formated_events = [self._format_db_items(event) for event in events]\n\n        if formated_events:\n            return {'data': str(formated_events)}, 200\n        return {'error': 'Events not found'}, 404\n\n    def _format_db_items(self, item):\n        new_item = {\n            'id': item[0],\n            'title': item[1],\n            'start': item[2].isoformat(),\n            'end': item[3].isoformat(),\n            'description': item[6],\n            'creationId': item[4]\n        }\n        app.logger.info(f\"Formatted DB item: {new_item}\")\n        return new_item \n            \nclass Database(Resource):\n    def __init__(self):\n        self.conn = create_database_connection()\n        self.cursor = self.conn.cursor()\n        self.base_url = os.getenv('EVENT_VIEW_URL', 'http://localhost:5000')\n        \n    def get(self):\n        return {'message': 'This is the Database endpoint'}\n    \n    def post(self):\n        # Add multiple calendar events to the database\n        data = request.get_json()\n        app.logger.info(f\"\\n POST request received at Database endpoint with data: {data}\")\n        \n        if not isinstance(data, list):\n            return {'error': 'Input data must be a list of events'}, 400\n        \n        add_event_query = (\"INSERT INTO events \"\n                           \"(title, start, end, description, creationId) \"\n                           \"VALUES (%s, %s, %s, %s, %s)\")\n        \n        creation_id = self._generate_unique_id()\n        try:\n            for event in data:\n                add_event_data = (event['name'], event['start'], event['end'], event['description'], creation_id)\n                app.logger.info(f\"\\n Adding event with creationId: {creation_id}\")\n                self.cursor.execute(add_event_query, add_event_data)\n            \n            self.conn.commit()\n            app.logger.info(\"All events added to the database successfully\")\n            return {'message': 'Events added successfully', 'link': self._generate_link(creation_id)}, 201\n        except mysql.connector.Error as err:\n            app.logger.error(f\"Error: {err}\")\n            self.conn.rollback()\n            return {'error': str(err)}, 500\n        \n    def _generate_unique_id(self):\n        self.cursor.execute(\"SELECT MAX(creationId) FROM events\")\n        max_id = self.cursor.fetchone()[0]\n        return (max_id or 0) + 1\n\n    def _generate_link(self, creation_id):\n        base_url = self.base_url\n        return f\"{base_url}/{creation_id}\"\n    \n# adding the defined resources along with their corresponding url\ndef create_database_connection():\n    try:\n        conn = mysql.connector.connect(\n            host=os.getenv('DB_HOST'),\n            user=DB_USER,\n            database=os.getenv('DB_NAME'),\n            password=DB_PASSWORD,\n            port=os.getenv('DB_PORT')\n        )\n        if conn.is_connected():\n            app.logger.info(\"Successfully connected to the database\")\n            return conn\n        else:\n            app.logger.error(\"Failed to connect to the database\")\n            return None\n    except mysql.connector.Error as err:\n        app.logger.error(f\"Error: {err}\")\n        return None\n\ndef close_database_connection(conn):\n    if conn and conn.is_connected():\n        conn.close()\n        app.logger.info(\"Database connection closed\")\n\n# driver function\nif __name__ == '__main__':\n    api.add_resource(Hello, '/')\n    api.add_resource(Square, '/square/')\n    api.add_resource(Link, '/link/')\n    api.add_resource(Database, '/database/')\n    api.add_resource(FetchEvents, '/fetch_events/')\n    app.run(debug=True, host='0.0.0.0')"
kind: ConfigMap
metadata:
  labels:
    io.kompose.service: link-provider
  name: link-provider-cm0
---
apiVersion: apps/v1
kind: Deployment
metadata:
  annotations:
    kompose.cmd: kompose convert
    kompose.version: 1.37.0 (HEAD)
  labels:
    io.kompose.service: link-provider
  name: link-provider
spec:
  replicas: 3
  selector:
    matchLabels:
      io.kompose.service: link-provider
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        io.kompose.service: link-provider
    spec:
      containers:
        - env:
            - name: DB_HOST
              value: event-store
            - name: DB_NAME
              value: event_store
            - name: DB_PORT
              value: "3306"
            - name: EVENT_VIEW_URL
              value: http://localhost:4200/signup
          image: arrow02/link-provider:latest
          name: link-provider
          ports:
            - containerPort: 5000
              protocol: TCP
          volumeMounts:
          - name: db-user
            mountPath: /run/secrets/db_user
            subPath: db-user
          - name: db-password
            mountPath: /run/secrets/db_password
            subPath: db-password
          - mountPath: /link-provider/app
            name: link-provider-cm0
      restartPolicy: Always
      volumes:
        - name: db-user
          secret:
            items:
              - key: db-user
                path: db-user
            secretName: db-user
        - name: db-password
          secret:
            items:
              - key: db-password
                path: db-password
            secretName: db-password
        - configMap:
            name: link-provider-cm0
          name: link-provider-cm0
---
apiVersion: v1
kind: Service
metadata:
  labels:
    io.kompose.service: link-provider
  name: link-provider
spec:
  type: NodePort
  ports:
    - name: "http"
      port: 5000
      targetPort: 5000
      nodePort: 31567  # Optional: specify a port in the range 30000-32767, or omit for auto-assignment
  selector:
    io.kompose.service: link-provider
